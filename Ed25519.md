# Ed25519 (Edwards-curve Digital Signature Algorithm)

## Overview

Ed25519 is a specific implementation of the EdDSA (Edwards-curve Digital Signature Algorithm) using the Curve25519 elliptic curve. It provides fast, secure digital signatures with deterministic behavior and built-in protection against many common cryptographic attacks.

## Mathematical Foundation

### Curve Definition

Ed25519 uses a twisted Edwards curve defined over the finite field $\mathbb{F}_q$ where:

**Prime modulus:** $q = 2^{255} - 19$

**Twisted Edwards curve equation:**
```
-x² + y² = 1 + dx²y²
```

where $d = -\frac{121665}{121666}$

### Point Representation

Points on the curve are represented in extended coordinates $(X, Y, Z, T)$ where:
- $x = X/Z$
- $y = Y/Z$  
- $xy = T/Z$

This representation allows for efficient point arithmetic without inversions.

### Point Addition Formula

For points $P_1 = (X_1, Y_1, Z_1, T_1)$ and $P_2 = (X_2, Y_2, Z_2, T_2)$:

```
A = (Y₁ - X₁)(Y₂ - X₂)
B = (Y₁ + X₁)(Y₂ + X₂)
C = T₁ · 2d · T₂
D = Z₁ · 2 · Z₂
E = B - A
```
$$F = D - C$$
$$G = D + C$$
$$H = B + A$$

**Result:** $P_1 + P_2 = (EF, GH, FG, EH)$

### Base Point

**Base point** $B$ has coordinates:
- $B_y = 4/5 \pmod{q}$
- $B_x$ is recovered from the curve equation with the constraint that $B_x$ is even

## Ed25519 Algorithm

### Key Generation

1. **Generate private key:** 32 random bytes $k$
2. **Hash private key:** $h = \text{SHA-512}(k)$
3. **Process hash:**
   - Take first 32 bytes: $h_0, h_1, \ldots, h_{31}$
   - Clamp: $h_0 \leftarrow h_0 \& 248$, $h_{31} \leftarrow h_{31} \& 127$, $h_{31} \leftarrow h_{31} | 64$
   - Form scalar: $s = \sum_{i=0}^{31} 2^{8i} h_i$
4. **Compute public key:** $A = sB$ (scalar multiplication)

### Signature Generation

To sign message $M$ with private key $k$:

1. **Hash private key:** $h = \text{SHA-512}(k)$
2. **Compute nonce:** $r = \text{SHA-512}(h_{32} \| \cdots \| h_{63} \| M) \bmod \ell$
3. **Compute point:** $R = rB$
4. **Compute challenge:** $S = \text{SHA-512}(\text{encode}(R) \| \text{encode}(A) \| M) \bmod \ell$  
5. **Compute response:** $s = (r + S \cdot \text{private_scalar}) \bmod \ell$
6. **Output signature:** $(\text{encode}(R), \text{encode}(s))$

where $\ell = 2^{252} + 27742317777372353535851937790883648493$ is the order of the base point.

### Signature Verification

To verify signature $(R, s)$ on message $M$ with public key $A$:

1. **Check bounds:** Verify $0 \leq s < \ell$ and $R$ is valid point
2. **Compute challenge:** $S = \text{SHA-512}(\text{encode}(R) \| \text{encode}(A) \| M) \bmod \ell$
3. **Verify equation:** Check if $sB = R + SA$

## Security Properties

### Advantages over ECDSA

- **Deterministic signatures:** No random nonce required, eliminates nonce reuse attacks
- **Fast performance:** Optimized for modern 64-bit processors
- **Side-channel resistance:** Built-in protection against timing attacks
- **Small signatures:** 64 bytes total (32 bytes R + 32 bytes s)
- **Fast verification:** Approximately 2-3x faster than P-256 ECDSA

### Security Level

- **Equivalent security:** ~128 bits (comparable to AES-128)
- **Quantum resistance:** Vulnerable to Shor's algorithm like all current public-key systems
- **Collision resistance:** Uses SHA-512 internally

## Python Implementation

```python
import hashlib
import secrets
from typing import Tuple, Optional

# Ed25519 parameters
Q = 2**255 - 19  # Prime modulus
L = 2**252 + 27742317777372353535851937790883648493  # Base point order
D = -121665 * pow(121666, Q-2, Q) % Q  # Curve parameter d

# Base point coordinates
BY = 4 * pow(5, Q-2, Q) % Q
BX = pow((BY*BY - 1) * pow(D*BY*BY + 1, Q-2, Q), (Q+3)//8, Q)
if BX % 2 != 0:
    BX = Q - BX

# Base point in extended coordinates
BASE_POINT = (BX, BY, 1, BX * BY % Q)

def mod_inverse(x: int) -> int:
    """Compute modular inverse using Fermat's little theorem"""
    return pow(x, Q - 2, Q)

def point_add(p1: Tuple[int, int, int, int], p2: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:
    """Add two points in extended coordinates"""
    x1, y1, z1, t1 = p1
    x2, y2, z2, t2 = p2
    
    a = (y1 - x1) * (y2 - x2) % Q
    b = (y1 + x1) * (y2 + x2) % Q
    c = t1 * 2 * D * t2 % Q
    d = z1 * 2 * z2 % Q
    e = b - a
    f = d - c
    g = d + c
    h = b + a
    
    return (e * f % Q, g * h % Q, f * g % Q, e * h % Q)

def point_double(p: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:
    """Double a point in extended coordinates"""
    x, y, z, t = p
    
    a = x * x % Q
    b = y * y % Q
    c = 2 * z * z % Q
    h = a + b
    e = h - (x + y) * (x + y) % Q
    g = a - b
    f = c + g
    
    return (e * f % Q, g * h % Q, f * g % Q, e * h % Q)

def scalar_mult(k: int, point: Tuple[int, int, int, int]) -> Tuple[int, int, int, int]:
    """Scalar multiplication using Montgomery ladder"""
    if k == 0:
        return (0, 1, 1, 0)  # Identity element
    if k == 1:
        return point
    
    # Convert k to binary and process from MSB to LSB
    result = (0, 1, 1, 0)  # Identity element
    addend = point
    
    while k:
        if k & 1:
            result = point_add(result, addend)
        addend = point_double(addend)
        k >>= 1
    
    return result

def point_to_bytes(point: Tuple[int, int, int, int]) -> bytes:
    """Encode point to 32-byte representation"""
    x, y, z, t = point
    
    # Convert to affine coordinates
    z_inv = mod_inverse(z)
    x = x * z_inv % Q
    y = y * z_inv % Q
    
    # Encode y-coordinate with x parity bit
    result = y.to_bytes(32, 'little')
    if x & 1:
        result = bytes([result[31] | 0x80]) + result[:31]
    
    return result

def bytes_to_point(data: bytes) -> Optional[Tuple[int, int, int, int]]:
    """Decode 32-byte representation to point"""
    if len(data) != 32:
        return None
    
    # Extract y coordinate and x parity
    y = int.from_bytes(data, 'little') & ((1 << 255) - 1)
    x_odd = bool(data[31] & 0x80)
    
    if y >= Q:
        return None
    
    # Recover x coordinate from curve equation
    # x^2 = (y^2 - 1) / (d*y^2 + 1)
    y2 = y * y % Q
    u = (y2 - 1) % Q
    v = (D * y2 + 1) % Q
    
    # Check if v is invertible
    if v == 0:
        return None
    
    x2 = u * mod_inverse(v) % Q
    x = pow(x2, (Q + 3) // 8, Q)
    
    # Check if x^2 == x2
    if (x * x - x2) % Q != 0:
        x = x * pow(2, (Q - 1) // 4, Q) % Q
        if (x * x - x2) % Q != 0:
            return None
    
    # Ensure correct parity
    if (x & 1) != x_odd:
        x = Q - x
    
    # Return in extended coordinates
    return (x, y, 1, x * y % Q)

def clamp_scalar(scalar: bytes) -> int:
    """Clamp scalar according to Ed25519 specification"""
    if len(scalar) != 32:
        raise ValueError("Scalar must be 32 bytes")
    
    # Convert to integer
    s = int.from_bytes(scalar, 'little')
    
    # Clamp bits
    s &= (1 << 254) - 1  # Clear top 2 bits
    s &= ~7  # Clear bottom 3 bits
    s |= 1 << 254  # Set bit 254
    
    return s

def generate_keypair() -> Tuple[bytes, bytes]:
    """Generate Ed25519 key pair"""
    # Generate 32 random bytes for private key
    private_key = secrets.token_bytes(32)
    
    # Hash private key
    h = hashlib.sha512(private_key).digest()
    
    # Clamp the first 32 bytes
    clamped = clamp_scalar(h[:32])
    
    # Compute public key: A = s*B
    public_point = scalar_mult(clamped, BASE_POINT)
    public_key = point_to_bytes(public_point)
    
    return private_key, public_key

def sign(message: bytes, private_key: bytes) -> bytes:
    """Sign message using Ed25519"""
    if len(private_key) != 32:
        raise ValueError("Private key must be 32 bytes")
    
    # Hash private key
    h = hashlib.sha512(private_key).digest()
    clamped = clamp_scalar(h[:32])
    
    # Compute public key
    public_point = scalar_mult(clamped, BASE_POINT)
    public_key = point_to_bytes(public_point)
    
    # Compute nonce
    r_hash = hashlib.sha512(h[32:] + message).digest()
    r = int.from_bytes(r_hash, 'little') % L
    
    # Compute R = r*B
    R_point = scalar_mult(r, BASE_POINT)
    R_bytes = point_to_bytes(R_point)
    
    # Compute challenge S = H(R || A || M) mod L
    S_hash = hashlib.sha512(R_bytes + public_key + message).digest()
    S = int.from_bytes(S_hash, 'little') % L
    
    # Compute s = (r + S*clamped) mod L
    s = (r + S * clamped) % L
    
    # Return signature: R || s
    return R_bytes + s.to_bytes(32, 'little')

def verify(message: bytes, signature: bytes, public_key: bytes) -> bool:
    """Verify Ed25519 signature"""
    if len(signature) != 64:
        return False
    if len(public_key) != 32:
        return False
    
    # Split signature
    R_bytes = signature[:32]
    s_bytes = signature[32:]
    
    # Decode R and s
    R_point = bytes_to_point(R_bytes)
    if R_point is None:
        return False
    
    s = int.from_bytes(s_bytes, 'little')
    if s >= L:
        return False
    
    # Decode public key
    A_point = bytes_to_point(public_key)
    if A_point is None:
        return False
    
    # Compute challenge S = H(R || A || M) mod L
    S_hash = hashlib.sha512(R_bytes + public_key + message).digest()
    S = int.from_bytes(S_hash, 'little') % L
    
    # Verify: s*B = R + S*A
    left = scalar_mult(s, BASE_POINT)
    right = point_add(R_point, scalar_mult(S, A_point))
    
    # Compare points (convert to canonical form)
    left_bytes = point_to_bytes(left)
    right_bytes = point_to_bytes(right)
    
    return left_bytes == right_bytes

def point_is_valid(point_bytes: bytes) -> bool:
    """Check if bytes represent a valid point on the curve"""
    return bytes_to_point(point_bytes) is not None

# Example usage
if __name__ == "__main__":
    print("Generating Ed25519 key pair...")
    private_key, public_key = generate_keypair()
    
    print(f"Private key: {private_key.hex()}")
    print(f"Public key: {public_key.hex()}")
    
    # Sign a message
    message = b"Hello, Ed25519!"
    print(f"\nSigning message: {message}")
    
    signature = sign(message, private_key)
    print(f"Signature: {signature.hex()}")
    
    # Verify the signature
    is_valid = verify(message, signature, public_key)
    print(f"Signature valid: {is_valid}")
    
    # Test with wrong message
    wrong_message = b"Hello, Ed25519 modified!"
    is_valid_wrong = verify(wrong_message, signature, public_key)
    print(f"Wrong message signature valid: {is_valid_wrong}")
    
    # Performance comparison (approximate)
    import time
    
    # Time signature generation
    start = time.time()
    for _ in range(1000):
        sign(message, private_key)
    sign_time = time.time() - start
    
    # Time signature verification
    start = time.time()
    for _ in range(1000):
        verify(message, signature, public_key)
    verify_time = time.time() - start
    
    print(f"\nPerformance (1000 operations):")
    print(f"Signature generation: {sign_time:.3f} seconds")
    print(f"Signature verification: {verify_time:.3f} seconds")
```

## Comparison with Other Signature Schemes

| Property | Ed25519 | ECDSA P-256 | RSA-2048 |
|----------|---------|-------------|-----------|
| **Signature Size** | 64 bytes | ~70 bytes | 256 bytes |
| **Public Key Size** | 32 bytes | ~65 bytes | 256 bytes |
| **Security Level** | ~128 bits | ~128 bits | ~112 bits |
| **Deterministic** | Yes | No (with RFC 6979) | No |
| **Side-channel Resistant** | Yes | Depends | Depends |
| **Verification Speed** | Fast | Medium | Slow |
| **Signature Speed** | Fast | Medium | Very Slow |

## Applications

- **SSH:** Modern OpenSSH implementations support Ed25519
- **TLS 1.3:** Ed25519 certificates and signatures
- **Signal Protocol:** Used for identity keys
- **Cryptocurrencies:** Some altcoins use Ed25519
- **Git:** Commit signing with Ed25519 keys
- **Age encryption:** Modern file encryption tool

## Security Considerations

### Strengths
- **No nonce reuse vulnerability:** Deterministic signatures eliminate this risk
- **Twist security:** Resistant to small-subgroup attacks
- **Side-channel resistance:** Constant-time implementations possible
- **Simple implementation:** Fewer edge cases than ECDSA

### Potential Weaknesses
- **Quantum vulnerability:** Like all current public-key systems
- **Implementation bugs:** Incorrect clamping or point validation
- **Fault attacks:** Physical attacks on hardware implementations

## Standards and References

- **RFC 8032:** Edwards-Curve Digital Signature Algorithm (EdDSA)
- **FIPS 186-5:** Digital Signature Standard (includes EdDSA)
- **Curve25519:** Original curve design by Daniel J. Bernstein
- **NaCl/libsodium:** Reference implementations

## References

- [RFC 8032: Edwards-Curve Digital Signature Algorithm (EdDSA)](https://tools.ietf.org/html/rfc8032)
- [EdDSA for more curves](https://ed25519.cr.yp.to/)
- [The Security Impact of a New Cryptographic Library](https://cr.yp.to/highspeed/coolnacl-20120725.pdf)
- [SafeCurves: choosing safe curves for elliptic-curve cryptography](https://safecurves.cr.yp.to/)